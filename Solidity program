/**
   * @title ContractName
   * @dev ContractDescription
   * @custom:dev-run-script file_path
   * @custom:dev-run-script NatSpec tag
   */
// SPDX-License-Identifier: MIT

// When a person opens the website and fills his personal details in th registration window.
// Unique ID (public key) and private key are generated.
// Secret = (Private key ^ Nonce) is calculated.
// Secret and Unique ID are shared to user through email or SMS
// User then enters verification window. Enters Secret and Unique ID and verifies himself

pragma solidity 0.8.18;

contract MyContract {

    uint256 public peopleCount = 0;
    uint _flag;
    uint public seed;
    uint private zkp_seed;
    uint private nonce;
    uint private zkp_nonce;    

    mapping(string => Person) private people;
    mapping(address => Block) public merkletree;
    //mapping (address => uint256) public balanceOf;

    address owner;   // owner is recognized by his address - owner = organisation
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    ///// Open session for only 10 minutes (10*60 = 600sec)
    uint256 newTimestamp = block.timestamp + 600;
    modifier onlyWhileOpen() {
        require(block.timestamp <= newTimestamp);
        _;
    }

    constructor() public {
        owner = msg.sender;
        seed = 0;
        zkp_seed = 1;
    }

    //////// generate nonce from seed
    function generateRandomNonce() public onlyOwner returns (uint) {
        require(msg.sender == owner, "Only the owner can generate a random nonce");
        nonce = uint256(keccak256(abi.encodePacked(seed, block.timestamp, block.prevrandao)));   //block.difficulty has been replaced with block.prevrandao
        return(nonce);
    }

    //////// generate zkpnonce from zkp_seed
    event LogB(uint zkp_nonce);
    function generatezkp_nonce() public {
        zkp_nonce = uint256(keccak256(abi.encodePacked(zkp_seed, block.timestamp, block.prevrandao)));   //block.difficulty has been replaced with block.prevrandao
        emit LogB(zkp_nonce);
    }

    ///// information stored at server used for user verification
    string storedUniqueID = "ac1";  // public key
    uint privateKey = 0x123456;
    uint storedSecret;

    ///// information generated by server for block generation
    uint blockNonce = 456;
    address prevBlockHash = 0x03C6FcED478cBbC9a4FAB34eF9f40767739D1Ff7;

    ///// information input by the user 
    string name = "Vamshi";
    string houseaddress = "Amrita Vishwa Vidyapeetham";
    string email = "vamshis@am.amrita.edu";
    uint phonenumber = 1234567890;
    string IDName = "Aadhar";
    string IDNumber = "1111222233334444";
    uint trees = 4;
    string uniqueID = "ac1";  // public key - input given in verification window
    uint secret;// = privateKey^nonce;

    event LogC(uint secret);
    function calculateSecret() public onlyOwner {
        secret = privateKey^nonce;
        emit LogC(secret);
    }
    // secret = (private key ^ nonce) shared by server in email - input given in verification window

    event LogD(uint storedSecret);
    function calculateStoredSecret() public onlyOwner {
        storedSecret = privateKey^nonce;
        emit LogD(storedSecret);
    }

    ///// define user details
    struct Person {
        string _name;
        string _houseaddress;
        string _uniqueID;
        string _email;
        uint _phonenumber;
        string _IDName;
        string _IDNumber;
        uint _secret;
        uint _trees;
        address _fromAddress;
    }

    ///// define block details
    struct Block {
        uint _trees;// number of trees * amount of one tree
        uint _blockNonce;// = block.nonce;
        string _uniqueID;
        uint _timestam;// = block.timestamp;
        address blockHash;
        string _email;
    }

    ///// Increment counter upon successful addition of user - shows total number of donations made
    function incrementCount() internal {
        peopleCount += 1;
    }

    
    ///// Add user
    uint private treesCount;
    address private UserAccountAddress;
    function addPerson (string memory _name, string memory _houseaddress, string memory _uniqueID, string memory _email, uint _phonenumber, string memory _IDName, string memory _IDNumber, uint _secret, uint _trees, address _fromAddress) public onlyOwner returns (uint, address) {
        if(_secret == (privateKey^nonce)) {
            people[_uniqueID] = Person(_name, _houseaddress, _uniqueID, _email, _phonenumber, _IDName, _IDNumber, _secret, _trees, _fromAddress);
            incrementCount();
            treesCount = _trees;
            UserAccountAddress = _fromAddress;
            return(_trees, _fromAddress);
        } else {
            // add a default return statement for the non-reverting code path
            return (0, address(0));
        }
    }

    ///// View person details only by server
    function printPerson(string memory _uniqueID) public view onlyOwner returns (string memory, string memory, string memory, string memory, uint, string memory, string memory, uint, uint, address) {
        Person memory p = people[_uniqueID];
        return (p._name, p._houseaddress, p._uniqueID, p._email, p._phonenumber, p._IDName, p._IDNumber, p._secret, p._trees, p._fromAddress);
    }

    ///// Generate zkp for user verification before generating transaction h(secret||zkpnonce)
    //bytes32 _hash;
    event LogE(bytes32 _hash);
    function createZKP(string memory _secret, uint _zkpnonce) public returns (bytes32, uint) {
        bytes32 _hash = keccak256(abi.encodePacked(_secret, _zkpnonce, treesCount));
        emit LogE(_hash);
        return(_hash, _zkpnonce);
    }

    ///// Verify user using zkp before generating transaction h(secret||zkpnonce)
    function verifyZKP(uint _zkpnonce, bytes32 _hash) public onlyOwner returns (uint) {
        bytes32 _vhash = keccak256(abi.encodePacked(storedSecret, _zkpnonce, treesCount));
        if(_vhash == _hash) {
            _flag = 1;
            return(_flag);
        }
        else {
            return 0; // or any other value that indicates failure
        }
    }

    ///// Retrieve block details - only server and user (has two owners)
    function getBlockDetails() public view returns (uint256 timestamp, uint256 number, uint256 prevrandao) {
        timestamp = block.timestamp;
        number = block.number;
        prevrandao = block.prevrandao;
    }

    //address payable _contractAddress = payable(0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2);

    function receiveEther() payable public {
        // no need to do anything here
    }
    
    function getBalance() public view returns(uint) {
        return address(this).balance;
    }

    function transferEther(address payable receiverAddress) public {
        uint _amount = treesCount * 10 ether;
        //require(msg.value == _amount * 1 ether, "Incorrect ether value sent.");
        receiverAddress.transfer(_amount);
        }

}


